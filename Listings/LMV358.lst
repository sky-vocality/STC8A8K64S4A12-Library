C51 COMPILER V9.60.0.0   LMV358                                                            04/13/2021 19:30:18 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE LMV358
OBJECT MODULE PLACED IN .\Objects\LMV358.obj
COMPILER INVOKED BY: E:\KEIL5\C51\BIN\C51.EXE Core\Src\LMV358.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Core\Inc) DEBUG 
                    -OBJECTEXTEND PRINT(.\Listings\LMV358.lst) TABS(2) OBJECT(.\Objects\LMV358.obj)

line level    source

   1          /**
   2            ******************************************************************************
   3            * @file    LMV358.c
   4            * @author  NULL(基于PineconePi(基于宏晶科技STC15库函数进行修改)库函数进行修改)
   5            * @version V1.0.0
   6            * @date    12-April-2021
   7            * @brief  This file is used for config LMV358
   8            * @License:GNU General Public License v3.0         
   9            ******************************************************************************
  10            * @attention
  11            *
  12            *  
  13            * 
  14            * 
  15            ******************************************************************************
  16          **/
  17          #include "LMV358.h"
  18          ad_data_max[6] = {500,500,500,500,500,500};
*** WARNING C231 IN LINE 18 OF Core\Src\LMV358.c: 'ad_data_max': redefinition
  19          ad_data_min[6] = { 0,0,0,0,0,0};    
*** WARNING C231 IN LINE 19 OF Core\Src\LMV358.c: 'ad_data_min': redefinition
  20          left = 0, right = 0;
  21          left1 = 0, right1 = 0;
  22          left2 = 0, right2 = 0;
  23          //========================================================================
  24          // Function:void LMV358_start
  25          // Description:start the LMV358|描述: ??LMV358??
  26          // Parameter:NONE
  27          //       
  28          //       
  29          // Return:|返回: 
  30          // Version:VER1.0.0|版本: VER1.0.0
  31          // Date:2021-04-12|日期: 2021-4-12
  32          // Author: NULL|作者: NULL
  33          // Note:|备注:
  34          //  
  35          //  
  36          //  
  37          //  
  38          //  
  39          //========================================================================
  40          void LMV358_start()
  41          {
  42   1        ADC_InitTypeDef ADC_Init;
  43   1        ADC_Init.ADC_Px=ADC_P10;
  44   1        ADC_Init.ADC_Speed=ADC_180T;
  45   1        ADC_Init.ADC_Power=ENABLE;
  46   1        ADC_Init.ADC_AdjResult=ADC_RES_H2L8;
  47   1        ADC_Init.ADC_Polity=PolityHigh;
  48   1        ADC_Init.ADC_Interrupt=ENABLE;
  49   1        ADC_Inilize(&ADC_Init);
  50   1      }
  51          //========================================================================
  52          // Function:void LMV358_start
C51 COMPILER V9.60.0.0   LMV358                                                            04/13/2021 19:30:18 PAGE 2   

  53          // Description:Do data processing of ADC acquisition|描述: ????????
  54          // Parameter:unsigned char k  |??:adc???  P1.x
  55          //       
  56          //       
  57          // Return:|返回: 
  58          // Version:VER1.0.0|版本: VER1.0.0
  59          // Date:2021-04-12|日期: 2021-4-12
  60          // Author: NULL|作者: NULL
  61          // Note:|备注:
  62          //  
  63          //  
  64          //  
  65          //  
  66          //  
  67          //========================================================================
  68          unsigned int get_adc_averge(unsigned char k)
  69          {
  70   1        unsigned char cnt=0;
  71   1        unsigned int sum=0;
  72   1        unsigned char i,j;
  73   1        unsigned int temp=0;
  74   1        unsigned int data_temp[times]={0};
  75   1        
  76   1        unsigned char tem[5]={0};
  77   1        
  78   1        for (cnt=0;cnt<times;cnt++)
  79   1        {
  80   2          data_temp[cnt] = Get_ADC10bitResult(k);
  81   2          Delay_Us(100);
  82   2        }
  83   1        
  84   1        for (j=0;j<times-1;j++)
  85   1        {
  86   2          for (i=0;i<times-j-1;i++)
  87   2          {
  88   3             if (data_temp[i]>data_temp[i+1] )
  89   3             {
  90   4                temp = data_temp[i];
  91   4                data_temp[i] = data_temp[i+1];
  92   4                data_temp[i+1] = temp;
  93   4             }
  94   3           }
  95   2         }
  96   1        
  97   1         for(cnt=1;cnt<times-1;cnt++)
  98   1           sum += data_temp[cnt];
  99   1      
 100   1       return (sum/(times-2));
 101   1      }
 102          //========================================================================
 103          // Function:void InductorNormal()
 104          // Description:InductorNormal()|描述: ???
 105          // Parameter:NONE
 106          //       
 107          //       
 108          // Return:|返回: 
 109          // Version:VER1.0.0|版本: VER1.0.0
 110          // Date:2021-04-12|日期: 2021-4-12
 111          // Author: NULL|作者: NULL
 112          // Note:|备注:
 113          //  
 114          //========================================================================
C51 COMPILER V9.60.0.0   LMV358                                                            04/13/2021 19:30:18 PAGE 3   

 115          void InductorNormal()
 116          {
 117   1        unsigned char num[6]={0};
 118   1        
 119   1        num[0]=get_adc_averge(0);
 120   1        num[1]=get_adc_averge(1);
 121   1        num[2]=get_adc_averge(2);
 122   1        num[3]=get_adc_averge(3);
 123   1        num[4]=get_adc_averge(4);
 124   1        num[5]=get_adc_averge(5);
 125   1        
 126   1        if (num[0] < ad_data_min[0])            ad_data_min[0] = num[0];     // ?????
 127   1        else if (num[0] > ad_data_max[0])       ad_data_max[0] = num[0];     // ?????
 128   1        if (num[1] < ad_data_min[1])            ad_data_min[1] = num[1];
 129   1        else if (num[1] > ad_data_max[1])       ad_data_max[1] = num[1]; 
 130   1        if (num[2] < ad_data_min[2])            ad_data_min[2] = num[2];
 131   1        else if (num[2] > ad_data_max[2])       ad_data_max[2] = num[2];
 132   1        if (num[3] < ad_data_min[3])            ad_data_min[3] = num[3];
 133   1        else if (num[3] > ad_data_max[3])       ad_data_max[3] = num[3];  
 134   1        if (num[4] < ad_data_min[4])            ad_data_min[4] = num[4];
 135   1        else if (num[4] > ad_data_max[4])       ad_data_max[4] = num[4];
 136   1        if (num[5] < ad_data_min[5])            ad_data_min[5] = num[5];
 137   1        else if (num[5] > ad_data_max[5])       ad_data_max[5] = num[5];
 138   1        
 139   1        left = (num[0] - ad_data_min[0]) * 100 / (ad_data_max[0] - ad_data_min[0]);     // ????????0--1000??
 140   1        right = (num[5] - ad_data_min[5]) * 100 / (ad_data_max[5] - ad_data_min[5]);
 141   1        left1 = (num[1] - ad_data_min[1]) * 100 / (ad_data_max[1] - ad_data_min[1]);     // ????????0--1000??
 142   1        right1 = (num[4] - ad_data_min[4]) * 100 / (ad_data_max[4] - ad_data_min[4]);
 143   1        left2 = (num[2] - ad_data_min[2]) * 100 / (ad_data_max[2] - ad_data_min[2]);     // ????????0--1000??
 144   1        right2 = (num[3] - ad_data_min[3]) * 100 / (ad_data_max[3] - ad_data_min[3]);
 145   1        
 146   1      }
 147          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1149    ----
   CONSTANT SIZE    =     35    ----
   XDATA SIZE       =     36      47
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
