C51 COMPILER V9.59.0.0   LMV358                                                            07/20/2021 16:32:11 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE LMV358
OBJECT MODULE PLACED IN .\Objects\LMV358.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Core\Src\LMV358.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Core\Inc) DEBU
                    -G OBJECTEXTEND PRINT(.\Listings\LMV358.lst) OBJECT(.\Objects\LMV358.obj)

line level    source

   1          /**
   2            ******************************************************************************
   3            * @file    LMV358.c
   4            * @author  NULL
   5            * @version V1.0.0
   6            * @date    12-April-2021
   7            * @brief  This file is used for config LMV358
   8            * @License:GNU General Public License v3.0         
   9            ******************************************************************************
  10            * @attention
  11            *
  12            *  
  13            * 
  14            * 
  15            ********************************************************************************/
  16                  
  17          #include "LMV358.h"
  18          
  19          /*unsigned int ad_data_max[6] = {240,240,240,240,240,240};
  20          unsigned int ad_data_min[6] = { 75,75,75,75,75,75};*/  //六路采集
  21          unsigned int ad_data_max[2] = {240,240};  //两路采集
  22          unsigned int ad_data_min[2] = { 75,75}; 
  23          unsigned int left = 0, right = 0;
  24          /*
  25          int left1 = 0, right1 = 0;
  26          int left2 = 0, right2 = 0;
  27          */
  28          
  29          //========================================================================
  30          // Function:LMV358_Init
  31          // Description:start the LMV358|描述: 初始化LMV358模块，并开启P1.x的adc采集
  32          // Parameter:NONE
  33          //       
  34          //       
  35          // Return:|返回: 
  36          // Version:VER1.0.0|版本: VER1.0.0
  37          // Date:2021-04-12|日期: 2021-04-12
  38          // Author: NULL|作者: NULL
  39          // Note:|备注:
  40          //      
  41          //      
  42          //      
  43          //========================================================================
  44          
  45          void LMV358_Init()
  46          {
  47   1              ADC_InitTypeDef ADC_Init;
  48   1              ADC_Init.ADC_Px=ADC_P10;                          //更改此处替换adc采集的IO口
  49   1              ADC_Init.ADC_Speed=ADC_540T;
  50   1              ADC_Init.ADC_Power=ENABLE;
  51   1              ADC_Init.ADC_AdjResult=ADC_RES_H2L8;
  52   1              ADC_Init.ADC_Polity=PolityHigh;
  53   1              ADC_Init.ADC_Interrupt=ENABLE;
  54   1              ADC_Inilize(&ADC_Init);
C51 COMPILER V9.59.0.0   LMV358                                                            07/20/2021 16:32:11 PAGE 2   

  55   1      }
  56          
  57          //========================================================================
  58          // Function:LMV358_GetAvergeData()
  59          // Description:Do data processing of ADC acquisition|描述:中值平均滤波，取值次数为times(12)次
  60          // Parameter:unsigned char k  |参数: P1.x的通道号k
  61          //       
  62          //       
  63          // Return:unsigned int|返回: 返回处理后的电感信号(单通道)
  64          // Version:VER1.0.0|版本: VER1.0.0
  65          // Date:2021-04-12|日期: 2021-04-12
  66          // Author: NULL|作者: NULL
  67          // Note:|备注:
  68          //      
  69          //      
  70          //========================================================================
  71          
  72          unsigned int LMV358_GetAvergeData(unsigned char k)
  73          {
  74   1              unsigned char cnt=0;
  75   1              unsigned char i,j;
  76   1              unsigned int temp=0;
  77   1              unsigned int data_temp[times]={0};
  78   1              //unsigned int t=0;
  79   1              for (cnt=0;cnt<times;cnt++)
  80   1          {
  81   2                      
  82   2                      if((data_temp[cnt] = Get_ADC10bitResult(k))==1024)
  83   2                      {
  84   3                              if(cnt==0)
  85   3                              {
  86   4                                      data_temp[cnt]=0;
  87   4                              }
  88   3                              else
  89   3                              {
  90   4                                      data_temp[cnt]=data_temp[cnt-1];
  91   4                              }
  92   3                      }
  93   2              }
  94   1              
  95   1          for (j=0;j<times-1;j++)
  96   1          {
  97   2                      for (i=0;i<times-j-1;i++)
  98   2              {
  99   3                  if (data_temp[i]>data_temp[i+1] )
 100   3                  {
 101   4                      temp = data_temp[i];
 102   4                      data_temp[i] = data_temp[i+1];
 103   4                      data_temp[i+1] = temp;
 104   4                  }
 105   3              }
 106   2          }
 107   1              
 108   1      return data_temp[times/2];
 109   1      }
 110          
 111          //========================================================================
 112          // Function:LMV358_InductorNormal()
 113          // Description:Do InductorNormal work|描述: 对六路采集回的电感做归一化处理（1000以内）
 114          // Parameter:NONE     
 115          // Return:None|返回: 无返回值
 116          // Version:VER1.0.0|版本: VER1.0.0
C51 COMPILER V9.59.0.0   LMV358                                                            07/20/2021 16:32:11 PAGE 3   

 117          // Date:2021-04-12|日期: 2021-04-12
 118          // Author: NULL|作者: NULL
 119          // Note:|备注:
 120          //      
 121          //========================================================================
 122          
 123          void LMV358_InductorNormal()
 124          {
 125   1              //unsigned int num[6]={0};
 126   1              unsigned int num[2]={0};
 127   1              
 128   1              /*num[0]=LMV358_GetAvergeData(0);
 129   1              num[1]=LMV358_GetAvergeData(1);*/
 130   1              num[0]=LMV358_GetAvergeData(1);
 131   1              num[1]=LMV358_GetAvergeData(4);
 132   1              /*num[4]=LMV358_GetAvergeData(4);
 133   1              num[5]=LMV358_GetAvergeData(5);*/
 134   1              
 135   1              /*if (num[0] < ad_data_min[0])            ad_data_min[0] = num[0];     
 136   1              else if (num[0] > ad_data_max[0])       ad_data_max[0] = num[0];     
 137   1              if (num[1] < ad_data_min[1])            ad_data_min[1] = num[1];
 138   1              else if (num[1] > ad_data_max[1])       ad_data_max[1] = num[1]; */
 139   1              if (num[0] < ad_data_min[0])            ad_data_min[0] = num[0];
 140   1              else if (num[0] > ad_data_max[0])       ad_data_max[0] = num[0];
 141   1              if (num[1] < ad_data_min[1])            ad_data_min[1] = num[1];
 142   1              else if (num[1] > ad_data_max[1])       ad_data_max[1] = num[1];        
 143   1              /*if (num[4] < ad_data_min[4])            ad_data_min[4] = num[4];
 144   1              else if (num[4] > ad_data_max[4])       ad_data_max[4] = num[4];
 145   1              if (num[5] < ad_data_min[5])            ad_data_min[5] = num[5];
 146   1              else if (num[5] > ad_data_max[5])       ad_data_max[5] = num[5];*/
 147   1              
 148   1              /*left = (num[0] - ad_data_min[0]) * 100 / (ad_data_max[0] - ad_data_min[0]);     
 149   1              right = (num[5] - ad_data_min[5]) * 100 / (ad_data_max[5] - ad_data_min[5]);
 150   1              left1 = (num[1] - ad_data_min[1]) * 100 / (ad_data_max[1] - ad_data_min[1]);     
 151   1              right1 = (num[4] - ad_data_min[4]) * 100 / (ad_data_max[4] - ad_data_min[4]);*/
 152   1              left = (num[0] - ad_data_min[0]) * 100 / (ad_data_max[0] - ad_data_min[0]);     
 153   1              right = (num[1] - ad_data_min[1]) * 100 / (ad_data_max[1] - ad_data_min[1]);
 154   1              
 155   1      }
 156          
 157          //========================================================================
 158          // Function:LMV358_Output()
 159          // Description:Output the final process|描述: 差比和算法输出误差
 160          // Parameter:NONE     
 161          // Return:error|返回: 
 162          // Version:VER1.0.0|版本: VER1.0.0
 163          // Date:2021-05-13|日期: 2021-05-13
 164          // Author: NULL|作者: NULL
 165          // Note:|备注:
 166          //      
 167          //========================================================================
 168          
 169          float LMV358_Output()
 170          {
 171   1              float error;
 172   1              //LMV358_InductorNormal();
 173   1              //error = ((right-left)<<7)/(right+left)*1.;
 174   1              error = (int)LMV358_GetAvergeData(1) - (int)LMV358_GetAvergeData(4);
 175   1              return error;
 176   1      }
 177          
 178          void LMV358_timer_init()
C51 COMPILER V9.59.0.0   LMV358                                                            07/20/2021 16:32:11 PAGE 4   

 179          {
 180   1              TIM_InitTypeDef TIM_InitTypeDef;
 181   1              LMV358_Init();
 182   1              TIM_InitTypeDef.TIM_Mode = TIM_16BitAutoReload;
 183   1              TIM_InitTypeDef.TIM_Polity = PolityLow;
 184   1              TIM_InitTypeDef.TIM_Interrupt = ENABLE;
 185   1              TIM_InitTypeDef.TIM_ClkSource = TIM_CLOCK_1T;
 186   1              TIM_InitTypeDef.TIM_ClkOut = ENABLE;
 187   1              TIM_InitTypeDef.TIM_Value = 41536;
 188   1              TIM_InitTypeDef.TIM_Run = ENABLE;
 189   1              Timer_Inilize(Timer2, &TIM_InitTypeDef);
 190   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    686    ----
   CONSTANT SIZE    =     28    ----
   XDATA SIZE       =     12      46
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
