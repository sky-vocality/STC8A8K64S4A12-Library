C51 COMPILER V9.59.0.0   MPU6050                                                           07/20/2021 16:32:12 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MPU6050
OBJECT MODULE PLACED IN .\Objects\mpu6050.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Core\Src\mpu6050.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Core\Inc) DEB
                    -UG OBJECTEXTEND PRINT(.\Listings\mpu6050.lst) OBJECT(.\Objects\mpu6050.obj)

line level    source

   1          /**
   2           ******************************************************************************
   3           * @file    mpu6050.c
   4           * @author  sky-vocality
   5           * @version V1.0.0
   6           * @date    18-July-2021
   7           * @brief  This file is used for drive mpu6050
   8           * @License:GNU General Public License v3.0         
   9           ******************************************************************************
  10           * @attention
  11           * 
  12           * 
  13           * 
  14           * 
  15           * 
  16           * 
  17           * 
  18           * 
  19           ******************************************************************************
  20          **/
  21          
  22          #include "mpu6050.h"
  23          
  24          MPU6050_InitDefine mpu6050 = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
  25          float q0 = 1, q1 = 0, q2 = 0, q3 = 0;           //四元数
  26          float exInt = 0, eyInt = 0, ezInt = 0;          //叉积计算误差的累计积分
  27          
  28          void MPU_Init()
  29          {
  30   1          IIC_host_Slave_machine(host_machine);//初始化IIC总线
  31   1      
  32   1          MPU_Write_Byte(MPU_PWR_MGMT1_REG,0X80);//复位MPU6050
  33   1          Delay_Ms(100);
  34   1          MPU_Write_Byte(MPU_PWR_MGMT1_REG,0X00);//唤醒MPU6050
  35   1          MPU_Set_Gyro_Fsr(2); //陀螺仪传感器,±1000dps
  36   1          MPU_Set_Accel_Fsr(0); //加速度传感器 ±2g
  37   1          MPU_Set_Rate(50); //设置采样率50HZ
  38   1          MPU_Write_Byte(MPU_INT_EN_REG,0X00); //关闭所有中断
  39   1          MPU_Write_Byte(MPU_USER_CTRL_REG,0X00);//I2C主模式关闭
  40   1          MPU_Write_Byte(MPU_FIFO_EN_REG,0X00);//关闭FIFO
  41   1          MPU_Write_Byte(MPU_INTBP_CFG_REG,0X80);//INT引脚低电平有效
  42   1      
  43   1          MPU_Write_Byte(MPU_PWR_MGMT1_REG,0X01);//设置CLKSEL,PLL X 轴为参考
  44   1          MPU_Write_Byte(MPU_PWR_MGMT2_REG,0X00);//加速度陀螺仪都工作
  45   1          MPU_Set_Rate(50); //设置采样率为50HZ
  46   1      }
  47          
  48          void MPU_Write_Byte(unsigned char reg,unsigned char dat)
  49          {
  50   1          P_SW2 = 0x90;
  51   1          Start();
  52   1              SendData(MPU6050_ADDR<<1);
  53   1              SendData(reg);
  54   1              SendData(dat);
C51 COMPILER V9.59.0.0   MPU6050                                                           07/20/2021 16:32:12 PAGE 2   

  55   1              Stop();
  56   1          P_SW2 = 0x00;
  57   1      }
  58          
  59          int MPU_Read_Byte(unsigned char reg)
  60          {
  61   1          unsigned char p0 = 0;
  62   1              int temp = 0;
  63   1              unsigned char p1 = 0;
  64   1          P_SW2 = 0x90;
  65   1          Start();
  66   1              SendData(MPU6050_ADDR<<1);
  67   1              SendData(reg);
  68   1          Start();
  69   1          SendData(MPU6050_ADDR<<1|1);
  70   1              p0 = RecvData();                            //Read data 1|读取数据1
  71   1              SendACK();
  72   1              p1 = RecvData();                            //读取数据2|读取数据2
  73   1              SendNAK();
  74   1              Stop();                                     //Send stop command|发送停止命令
  75   1          temp = ((unsigned int)p0<<8)|p1;
  76   1          P_SW2 = 0x00;
  77   1          return temp;
  78   1      }
  79          
  80          void MPU_Set_Gyro_Fsr(unsigned char fsr)
  81          {
  82   1          MPU_Write_Byte(MPU_GYRO_CFG_REG,fsr<<3);
  83   1      }
  84          
  85          void MPU_Set_Accel_Fsr(unsigned char fsr)
  86          {
  87   1          MPU_Write_Byte(MPU_ACCEL_CFG_REG,fsr<<3);
  88   1      }
  89          
  90          void MPU_Set_LPF(unsigned int lpf)
  91          {
  92   1          unsigned char dat=0;
  93   1          if(lpf>=188) dat=1;
  94   1          else if(lpf>=98) dat=2;
  95   1          else if(lpf>=42) dat=2;
  96   1          else if(lpf>=42) dat=3;
  97   1          else if(lpf>=20) dat=4;
  98   1          else if(lpf>=10) dat=5;
  99   1          else dat=6; 
 100   1          MPU_Write_Byte(MPU_CFG_REG,dat);//设置数字低通滤波器 
 101   1      }
 102          
 103          void MPU_Set_Rate(unsigned int rate)
 104          {
 105   1          unsigned char dat;
 106   1          if(rate>1000) rate=1000;
 107   1          if(rate<4) rate=4;
 108   1          dat=1000/rate-1;
 109   1          MPU_Write_Byte(MPU_SAMPLE_RATE_REG,dat);  //设置数字低通滤波器
 110   1          MPU_Set_LPF(rate/2); //自动设置LPF为采样率的一半
 111   1      }
 112          
 113          static float invSqrt(float x)           //快速计算 1/Sqrt(x)
 114          {
 115   1              float halfx = 0.5f * x;
 116   1              float y = x;
C51 COMPILER V9.59.0.0   MPU6050                                                           07/20/2021 16:32:12 PAGE 3   

 117   1              long i = *(long*)&y;
 118   1              i = 0x5f3759df - (i>>1);
 119   1              y = *(float*)&i;
 120   1              y = y * (1.5f - (halfx * y * y));
 121   1              return y;
 122   1      }
 123          
 124          void MPU_Update()
 125          {
 126   1              float vx,vy,vz;                                                 //实际重力加速度
 127   1              float ex,ey,ez;                                                 //叉积计算的误差
 128   1              float norm;
 129   1              
 130   1          float q0q0 = q0*q0;
 131   1          float q0q1 = q0*q1;
 132   1              float q0q2 = q0*q2;
 133   1              float q0q3 = q0*q3;
 134   1              float q1q1 = q1*q1;
 135   1          float q1q2 = q1*q2;
 136   1          float q1q3 = q1*q3;
 137   1              float q2q2 = q2*q2;
 138   1              float q2q3 = q2*q3;
 139   1              float q3q3 = q3*q3;
 140   1              
 141   1              mpu6050.Gx = ((double)MPU_Read_Byte(MPU_GYRO_XOUTH_REG)/32.8)*G;
 142   1              mpu6050.Gy = ((double)MPU_Read_Byte(MPU_GYRO_YOUTH_REG)/32.8)*G;
 143   1              mpu6050.Gz = ((double)MPU_Read_Byte(MPU_GYRO_ZOUTH_REG)/32.8)*G;
 144   1              
 145   1          mpu6050.Ax = ((double)MPU_Read_Byte(MPU_ACCEL_XOUTH_REG)/16384)/57.2957795;
 146   1              mpu6050.Ay = ((double)MPU_Read_Byte(MPU_ACCEL_YOUTH_REG)/16384)/57.2957795;
 147   1              mpu6050.Az = ((double)MPU_Read_Byte(MPU_ACCEL_ZOUTH_REG)/16384)/57.2957795;
 148   1              
 149   1              if(mpu6050.Ax*mpu6050.Ay*mpu6050.Az == 0)
 150   1                      return;
 151   1      
 152   1              //加速度计测量的重力方向(机体坐标系)
 153   1              norm = invSqrt(mpu6050.Ax*mpu6050.Ax + mpu6050.Ay*mpu6050.Ay + mpu6050.Az*mpu6050.Az);
 154   1              mpu6050.Ax = mpu6050.Ax * norm;
 155   1              mpu6050.Ay = mpu6050.Ay * norm;
 156   1              mpu6050.Az = mpu6050.Az * norm;
 157   1              
 158   1              //四元数推出的实际重力方向(机体坐标系)
 159   1              vx = 2*(q1q3 - q0q2);                                                                                           
 160   1          vy = 2*(q0q1 + q2q3);
 161   1          vz = q0q0 - q1q1 - q2q2 + q3q3;
 162   1              
 163   1              //叉积误差
 164   1              ex = (mpu6050.Ay*vz - mpu6050.Az*vy);
 165   1              ey = (mpu6050.Az*vx - mpu6050.Ax*vz);
 166   1              ez = (mpu6050.Ax*vy - mpu6050.Ay*vx);
 167   1              
 168   1              //叉积误差积分为角速度
 169   1              exInt = exInt + ex * Ki;
 170   1              eyInt = eyInt + ey * Ki;
 171   1              ezInt = ezInt + ez * Ki;
 172   1              
 173   1              //角速度补偿
 174   1              mpu6050.Gx = mpu6050.Gx + Kp*ex + exInt;
 175   1              mpu6050.Gy = mpu6050.Gy + Kp*ey + eyInt;
 176   1              mpu6050.Gz = mpu6050.Gz + Kp*ez + ezInt;
 177   1              
 178   1              //更新四元数
C51 COMPILER V9.59.0.0   MPU6050                                                           07/20/2021 16:32:12 PAGE 4   

 179   1          q0 = q0 + (-q1*mpu6050.Gx - q2*mpu6050.Gy - q3*mpu6050.Gz)*halfT;
 180   1          q1 = q1 + (q0*mpu6050.Gx + q2*mpu6050.Gz - q3*mpu6050.Gy)*halfT;
 181   1          q2 = q2 + (q0*mpu6050.Gy - q1*mpu6050.Gz + q3*mpu6050.Gx)*halfT;
 182   1          q3 = q3 + (q0*mpu6050.Gz + q1*mpu6050.Gy - q2*mpu6050.Gx)*halfT;    
 183   1              
 184   1              //单位化四元数
 185   1          norm = invSqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3);
 186   1          q0 = q0 * norm;
 187   1          q1 = q1 * norm;
 188   1          q2 = q2 * norm;  
 189   1          q3 = q3 * norm;
 190   1              
 191   1              //四元数反解欧拉角
 192   1              mpu6050.Yaw = atan2(2.f * (q1q2 + q0q3), q0q0 + q1q1 - q2q2 - q3q3)* 57.3f;
 193   1              mpu6050.Pitch = -asin(2.f * (q1q3 - q0q2))* 57.3f;
 194   1              mpu6050.Roll = atan2(2.f * q2q3 + 2.f * q0q1, q0q0 - q1q1 - q2q2 + q3q3)* 57.3f;
 195   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3835    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     64      91
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
