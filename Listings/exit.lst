C51 COMPILER V9.59.0.0   EXIT                                                              04/17/2021 21:56:59 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE EXIT
OBJECT MODULE PLACED IN .\Objects\exit.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Core\Src\exit.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Core\Inc) DEBUG 
                    -OBJECTEXTEND PRINT(.\Listings\exit.lst) OBJECT(.\Objects\exit.obj)

line level    source

   1          /**
   2            ******************************************************************************
   3            * @file    exti.c
   4            * @author  sky-vocality(»ùÓÚPineconePi(»ùÓÚºê¾§¿Æ¼¼STC15¿âº¯Êý½øÐÐÐÞ¸Ä)¿âº¯Êý½øÐÐÐÞ¸Ä)
   5            * @version V1.0.0
   6            * @date    20-January-2021
   7            * @brief  This file is used for external interrupt configuration
   8            * @License:GNU General Public License v3.0         
   9            ******************************************************************************
  10            * @attention
  11            *
  12            *  
  13            * 
  14            * 
  15            * 
  16            * 
  17            *
  18            * 
  19            ******************************************************************************
  20          **/
  21          
  22          #include "exit.h"
  23          
  24          int encoder_num = 0;
  25          
  26          /********************* INT0 interrupt function|INT0ÖÐ¶Ïº¯Êý *************************/
  27          void Ext_INT0 (void) interrupt EXT_INT0         //The sign has been cleared when entering or interrupting|½øÖÐ¶ÏÊ
             -±ÒÑ¾­Çå³ý±êÖ¾
  28          {
  29   1              //Add user logic here|´Ë´¦Ìí¼ÓÓÃ»§Âß¼­
  30   1      }
  31          
  32          /********************* INT1 interrupt function|INT1ÖÐ¶Ïº¯Êý *************************/
  33          void Ext_INT1 (void) interrupt EXT_INT1         //The sign has been cleared when entering or interrupting|½øÖÐ¶ÏÊ
             -±ÒÑ¾­Çå³ý±êÖ¾
  34          {
  35   1              //Add user logic here|´Ë´¦Ìí¼ÓÓÃ»§Âß¼­
  36   1      }
  37          
  38          /********************* INT2 interrupt function|INT2ÖÐ¶Ïº¯Êý *************************/
  39          void Ext_INT2 (void) interrupt EXT_INT2 //
  40          {
  41   1              //Add user logic here|´Ë´¦Ìí¼ÓÓÃ»§Âß¼­
  42   1      }
  43          
  44          /********************* INT3 interrupt function|INT3ÖÐ¶Ïº¯Êý *************************/
  45          void Ext_INT3 (void) interrupt EXT_INT3
  46          {
  47   1              //Add user logic here|´Ë´¦Ìí¼ÓÓÃ»§Âß¼­
  48   1      }
  49          
  50          /********************* INT4 interrupt function|INT4ÖÐ¶Ïº¯Êý *************************/
  51          void Ext_INT4 (void) interrupt EXT_INT4
  52          {
C51 COMPILER V9.59.0.0   EXIT                                                              04/17/2021 21:56:59 PAGE 2   

  53   1              //Add user logic here|´Ë´¦Ìí¼ÓÓÃ»§Âß¼­
  54   1      }
  55          
  56          /********************* PCA Interrupt Handling Function|PCA??????************************/
  57          void    PCA_Ext (void) interrupt PCA_INT0
  58          {
  59   1              if(CCF0)                //PCA module 0 interrupt|PCA??0??
  60   1              {
  61   2                      CCF0 = 0;               //Clear PCA module 0 interrupt flag|?PCA??0????
  62   2              }
  63   1      
  64   1              if(CCF1)        //PCA Module 1 Interruption|PCA??1??
  65   1              {
  66   2                      CCF1 = 0;               //Clear the interrupt flag in PCA module 1|?PCA??1????
  67   2                      encoder_num++;
  68   2              }
  69   1      
  70   1              if(CCF2)        //PCA Module 2 Interruption|PCA??2??
  71   1              {
  72   2                      CCF2 = 0;               //Clear the interrupt flag in PCA module 2|?PCA??2????
  73   2              }
  74   1      
  75   1                      if(CCF3)        //PCA Module 3 Interruption|PCA??3??
  76   1              {
  77   2                      CCF3 = 0;               //Clear the interrupt flag in PCA module 3|?PCA??3????
  78   2              }
  79   1      
  80   1      /*      if(CF)  //PCA????
  81   1              {
  82   1                      CF = 0;                 //?PCA??????
  83   1              }
  84   1      */
  85   1      }
  86          
  87          //========================================================================
  88          // Function:unsigned char Ext_Inilize(unsigned char EXT, EXTI_InitTypeDef *INTx)|º¯Êý: unsigned char Ext_I
             -nilize(unsigned char EXT, EXTI_InitTypeDef *INTx)
  89          // Description:External interrupt initializer|ÃèÊö: Íâ²¿ÖÐ¶Ï³õÊ¼»¯³ÌÐò.
  90          // Parameter:EXT,Interrupt sequence number£¨EXT_INT0£ºExternal interrupt 0 , EXT_INT1£ºExternal interrupt 
             -1 , EXT_INT2£ºExternal interrupt 2 , 
  91          //                                          EXT_INT3£ºExternal interrupt 3 £¬ EXT_INT4£ºExternal interrupt
             - 4)
  92          // ²ÎÊý: EXT,ÖÐ¶ÏÐòºÅ£¨EXT_INT0£ºÍâ²¿ÖÐ¶Ï0 , EXT_INT1£ºÍâ²¿ÖÐ¶Ï1 , EXT_INT2£ºÍâ²¿ÖÐ¶Ï2 , 
  93          //       EXT_INT3£ºÍâ²¿ÖÐ¶Ï3 £¬ EXT_INT4£ºÍâ²¿ÖÐ¶Ï4)
  94          //       INTx: ½á¹¹²ÎÊý,Çë²Î¿¼Exti.hÀïµÄ¶¨Òå.
  95          // Return:Successful return 0, empty return 1, error return 2.|·µ»Ø: ³É¹¦·µ»Ø0, ¿Õ²Ù×÷·µ»Ø1,´íÎó·µ»Ø2.
  96          // Version:VER1.0.0|°æ±¾: VER1.0.0
  97          // Date:2018-12-20|ÈÕÆÚ: 2018-12-20
  98          // Note: Enable INT0 by following steps
  99          //      EXTI_InitTypeDef EXTI_InitTypeDef;
 100          //      EXTI_InitTypeDef.EXTI_Mode = EXT_MODE_RiseFall;//Rising edge interruption
 101          //      EXTI_InitTypeDef.EXTI_Polity = PolityHigh;//High priority|¸ßÓÅÏÈ¼¶
 102          //      EXTI_InitTypeDef.EXTI_Interrupt = ENABLE;//Enable|Ê¹ÄÜ
 103          //      Ext_Inilize(EXT_INT0,&EXTI_InitTypeDef);//Complete configuration|Íê³ÉÅäÖÃ
 104          // ±¸×¢: Í¨¹ýÒÔÏÂ²½ÖèÊ¹ÄÜINT0
 105          //      EXTI_InitTypeDef EXTI_InitTypeDef;
 106          //      EXTI_InitTypeDef.EXTI_Mode = EXT_MODE_RiseFall;//ÉÏÉýÑØÖÐ¶Ï
 107          //      EXTI_InitTypeDef.EXTI_Polity = PolityHigh;//¸ßÓÅÏÈ¼¶
 108          //      EXTI_InitTypeDef.EXTI_Interrupt = ENABLE;//Ê¹ÄÜ
 109          //      Ext_Inilize(EXT_INT0,&EXTI_InitTypeDef);//Íê³ÉÅäÖÃ
 110          //========================================================================
 111          unsigned char Ext_Inilize(unsigned char EXT, EXTI_InitTypeDef *INTx)
C51 COMPILER V9.59.0.0   EXIT                                                              04/17/2021 21:56:59 PAGE 3   

 112          {
 113   1              if(EXT >  EXT_INT4)     return 1;       //Empty operation|¿Õ²Ù×÷
 114   1              
 115   1              EA = 1;
 116   1              
 117   1              if(EXT == EXT_INT0)     //External interrupt 0|ÍâÖÐ¶Ï0
 118   1              {
 119   2                      if(INTx->EXTI_Interrupt == ENABLE)              EX0 = 1;        //Allowed interruption|ÔÊÐíÖÐ¶Ï
 120   2                      else                                                                    EX0 = 0;        //No interruption|½ûÖ¹ÖÐ¶Ï
 121   2                      if(INTx->EXTI_Polity == PolityHigh)             PX0 = 1;        //High priority interrupt|¸ßÓÅÏÈ¼¶ÖÐ¶Ï
 122   2                      else                                                                    PX0 = 0;        //Low priority interrupt|µÍÓÅÏÈ¼¶ÖÐ¶Ï
 123   2                      if(INTx->EXTI_Mode == EXT_MODE_Fall)    IT0 = 1;        //Falling edge interruption|ÏÂ½µÑØÖÐ¶Ï
 124   2                      else                                                                    IT0 = 0;        //Rise, fall and interrupt|ÉÏÉý,ÏÂ½µÑØÖÐ¶Ï
 125   2                      return  0;              //Success|³É¹¦
 126   2              }
 127   1      
 128   1              if(EXT == EXT_INT1)     //External interrupt 1|ÍâÖÐ¶Ï1
 129   1              {
 130   2                      if(INTx->EXTI_Interrupt == ENABLE)              EX1 = 1;        //Allowed interruption|ÔÊÐíÖÐ¶Ï
 131   2                      else                                                                    EX1 = 0;        //No interruption|½ûÖ¹ÖÐ¶Ï
 132   2                      if(INTx->EXTI_Polity == PolityHigh)             PX1 = 1;        //High priority interrupt|¸ßÓÅÏÈ¼¶ÖÐ¶Ï
 133   2                      else                                                                    PX1 = 0;        //Low priority interrupt|µÍÓÅÏÈ¼¶ÖÐ¶Ï
 134   2                      if(INTx->EXTI_Mode == EXT_MODE_Fall)    IT1 = 1;        //Falling edge interruption|ÏÂ½µÑØÖÐ¶Ï
 135   2                      else                                                                    IT1 = 0;        //Rise, fall and interrupt|ÉÏÉý,ÏÂ½µÑØÖÐ¶Ï
 136   2                      return  0;              //Success|³É¹¦
 137   2              }
 138   1      
 139   1              if(EXT == EXT_INT2)             //Outer interrupt 2, fixed to lower priority interrupt|ÍâÖÐ¶Ï2, ¹Ì¶¨ÎªÏÂ½µÑØµÍÓÅÏÈ¼¶
             -ÖÐ¶Ï
 140   1              {
 141   2                      if(INTx->EXTI_Interrupt == ENABLE)      INTCLKO |=  (1 << 4);   //Allowed interruption|ÔÊÐíÖÐ¶Ï 
 142   2                      else                                                            INTCLKO &= ~(1 << 4);   //No interruption|½ûÖ¹ÖÐ¶Ï
 143   2                      return  0;              //Success|³É¹¦
 144   2              }
 145   1      
 146   1              if(EXT == EXT_INT3)             //Outer interrupt 3, fixed to lower priority interrupt|ÍâÖÐ¶Ï3, ¹Ì¶¨ÎªÏÂ½µÑØµÍÓÅÏÈ¼¶
             -ÖÐ¶Ï
 147   1              {
 148   2                      if(INTx->EXTI_Interrupt == ENABLE)      INTCLKO |=  (1 << 5);   //Allowed interruption|ÔÊÐíÖÐ¶Ï 
 149   2                      else                                                            INTCLKO &= ~(1 << 5);   //No interruption|½ûÖ¹ÖÐ¶Ï
 150   2                      return  0;              //Success|³É¹¦
 151   2              }
 152   1      
 153   1              if(EXT == EXT_INT4)             //External interrupt 4, fixed to lower priority interrupt|ÍâÖÐ¶Ï4, ¹Ì¶¨ÎªÏÂ½µÑØµÍÓÅÏ
             -È¼¶ÖÐ¶Ï
 154   1              {
 155   2                      if(INTx->EXTI_Interrupt == ENABLE)      INTCLKO |=  (1 << 6);   //Allowed interruption|ÔÊÐíÖÐ¶Ï 
 156   2                      else                                                            INTCLKO &= ~(1 << 6);   //No interruption|½ûÖ¹ÖÐ¶Ï
 157   2                      return  0;              //Success|³É¹¦
 158   2              }
 159   1      
 160   1              if(EXT == PCA_INT0)             //External interrupt 4, fixed to lower priority interrupt|ÍâÖÐ¶Ï4, ¹Ì¶¨ÎªÏÂ½µÑØµÍÓÅÏ
             -È¼¶ÖÐ¶Ï
 161   1              {
 162   2                      CCON = 0x00;
 163   2                      CMOD = 0x0d;
 164   2                      CL = 0x00;
 165   2                      CH = 0x00;
 166   2                      if (INTx->EXTI_Mode == EXT_MODE_Fall)  CCAPM0 = 0x11;
 167   2                      else CCAPM0 = 0x21;
 168   2                      CCAP0L = 0;
 169   2                      CCAP0H = 0;
C51 COMPILER V9.59.0.0   EXIT                                                              04/17/2021 21:56:59 PAGE 4   

 170   2                      CR = 1;
 171   2                      return  0;              //Success|³É¹¦
 172   2              }
 173   1      
 174   1              if(EXT == PCA_INT1)             //External interrupt 4, fixed to lower priority interrupt|ÍâÖÐ¶Ï4, ¹Ì¶¨ÎªÏÂ½µÑØµÍÓÅÏ
             -È¼¶ÖÐ¶Ï
 175   1              {
 176   2                      CCON = 0x00;
 177   2                      CMOD = 0x0d;
 178   2                      CL = 0x00;
 179   2                      CH = 0x00;
 180   2                      if (INTx->EXTI_Mode == EXT_MODE_Fall)  CCAPM1 = 0x11;
 181   2                      else CCAPM1 = 0x21;
 182   2                      CCAP1L = 0;
 183   2                      CCAP1H = 0;
 184   2                      CR = 1;
 185   2                      return  0;              //Success|³É¹¦
 186   2              }
 187   1      
 188   1              if(EXT == PCA_INT2)             //External interrupt 4, fixed to lower priority interrupt|ÍâÖÐ¶Ï4, ¹Ì¶¨ÎªÏÂ½µÑØµÍÓÅÏ
             -È¼¶ÖÐ¶Ï
 189   1              {
 190   2                      CCON = 0x00;
 191   2                      CMOD = 0x0d;
 192   2                      CL = 0x00;
 193   2                      CH = 0x00;
 194   2                      if (INTx->EXTI_Mode == EXT_MODE_Fall)  CCAPM2 = 0x11;
 195   2                      else CCAPM2 = 0x21;
 196   2                      CCAP2L = 0;
 197   2                      CCAP2H = 0;
 198   2                      CR = 1;
 199   2                      return  0;              //Success|³É¹¦
 200   2              }
 201   1      
 202   1              if(EXT == PCA_INT3)             //External interrupt 4, fixed to lower priority interrupt|ÍâÖÐ¶Ï4, ¹Ì¶¨ÎªÏÂ½µÑØµÍÓÅÏ
             -È¼¶ÖÐ¶Ï
 203   1              {
 204   2                      CCON = 0x00;
 205   2                      CMOD = 0x0d;
 206   2                      CL = 0x00;
 207   2                      CH = 0x00;
 208   2                      if (INTx->EXTI_Mode == EXT_MODE_Fall)  CCAPM3 = 0x11;
 209   2                      else CCAPM0 = 0x21;
 210   2                      CCAP3L = 0;
 211   2                      CCAP3H = 0;
 212   2                      CR = 1;
 213   2                      return  0;              //Success|³É¹¦
 214   2              }
 215   1              return 2;       //fail|Ê§°Ü
 216   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    398    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
