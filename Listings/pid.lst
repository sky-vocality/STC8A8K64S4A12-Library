C51 COMPILER V9.59.0.0   PID                                                               05/17/2021 08:55:41 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE PID
OBJECT MODULE PLACED IN .\Objects\pid.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Core\Src\pid.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Core\Inc) DEBUG O
                    -BJECTEXTEND PRINT(.\Listings\pid.lst) OBJECT(.\Objects\pid.obj)

line level    source

   1          /**
   2           ******************************************************************************
   3           * @file    pid.h
   4           * @author  sky-vocality
   5           * @version V1.0.1
   6           * @date    6-February-2021
   7           * @brief  This file is a PID regulator
   8           * @License:GNU General Public License v3.0     
   9           ******************************************************************************
  10           * @attention
  11           * 
  12           * 
  13           * 
  14           * 
  15           * 
  16           * 
  17           * 
  18           * 
  19           ******************************************************************************
  20          **/
  21          
  22          #include "pid.h"
  23          
  24          #define Inter_Max   5
  25          
  26          PID wheel_pid = {0.15, 0.45, 0.28, 0, 0, 0, 980, 0, 0};
  27          PID server_pid = {0.38886, 0.15, 0.04459, 0, 0, 0, 52.0, -52.0, 0};
  28          PID follow_pid = {0, 0, 0, 0, 0, 0, 6, 6, 0};
  29          
  30          void PID_Control(unsigned char pid_type, float current_position,float expected_position,PID* motor_type)
  31          {
  32   1              if(pid_type == position)
  33   1              {
  34   2                      //  float error_position;
  35   2                      motor_type->error_last=motor_type->error_now;
  36   2                      motor_type->error_now = expected_position - current_position;
  37   2                      motor_type->error_inter += motor_type->error_now;
  38   2                      // limit intergration of pid
  39   2                      if(motor_type->error_inter>Inter_Max)
  40   2                              motor_type->error_inter = Inter_Max;
  41   2                      if(motor_type->error_inter<-Inter_Max)
  42   2                              motor_type->error_inter = -Inter_Max;
  43   2              motor_type->pid_out = motor_type->Kp * motor_type->error_now + motor_type->Ki * motor_type->error_int
             -er + motor_type->Kd * (motor_type->error_now-motor_type->error_last);
  44   2              // limit out of pid
  45   2              if(motor_type->pid_out > motor_type->out_limit_max)
  46   2                  motor_type->pid_out = motor_type->out_limit_max;
  47   2              else if (motor_type->pid_out < motor_type->out_limit_low)
  48   2                  motor_type->pid_out = motor_type->out_limit_low;
  49   2              }
  50   1          else if(pid_type == increment)
  51   1              {
  52   2                      motor_type->error_last=motor_type->error_now;
  53   2                      motor_type->error_now = expected_position - current_position;
C51 COMPILER V9.59.0.0   PID                                                               05/17/2021 08:55:41 PAGE 2   

  54   2                      motor_type->pid_out += motor_type->Kp * (motor_type->error_now - motor_type->error_last) + motor_type->K
             -i * motor_type->error_now;
  55   2                      // limit out of pid
  56   2                      if(motor_type->pid_out > motor_type->out_limit_max)
  57   2                  motor_type->pid_out = motor_type->out_limit_max;
  58   2              else if (motor_type->pid_out < motor_type->out_limit_low)
  59   2                  motor_type->pid_out = motor_type->out_limit_low;
  60   2              }
  61   1              else if(pid_type == angle)
  62   1              {
  63   2                      //  float error_position;
  64   2                      motor_type->error_last=motor_type->error_now;
  65   2                      motor_type->error_now = expected_position + current_position;
  66   2                      motor_type->error_inter += current_position;
  67   2                      // limit intergration of pid
  68   2                      if(motor_type->error_inter>Inter_Max)
  69   2                              motor_type->error_inter = Inter_Max;
  70   2                      if(motor_type->error_inter<-Inter_Max)
  71   2                              motor_type->error_inter = -Inter_Max;
  72   2              motor_type->pid_out = motor_type->Kp * motor_type->error_now + motor_type->Ki * motor_type->error_int
             -er + motor_type->Kd * -jy901.Gx;
  73   2              // limit out of pid
  74   2              if(motor_type->pid_out > motor_type->out_limit_max)
  75   2                  motor_type->pid_out = motor_type->out_limit_max;
  76   2              else if (motor_type->pid_out < motor_type->out_limit_low)
  77   2                  motor_type->pid_out = motor_type->out_limit_low;
  78   2              }
  79   1      }
  80          
  81          void wheel_pid_timer_init()
  82          {
  83   1              TIM_InitTypeDef TIM_InitTypeDef;
  84   1              TIM_InitTypeDef.TIM_Mode = TIM_16BitAutoReload;         //Working mode|����ģʽ,        TIM_16BitAutoReload,T
             -IM_16Bit,TIM_8BitAutoReload,TIM_16BitAutoReloadNoMask
  85   1              TIM_InitTypeDef.TIM_Polity = PolityHigh;                //Priority Setting|���ȼ�����   PolityHigh,Polity
             -Low
  86   1              TIM_InitTypeDef.TIM_Interrupt = ENABLE; //Interrupt enable|�ж�����         ENABLE,DISABLE
  87   1              TIM_InitTypeDef.TIM_ClkSource = TIM_CLOCK_1T;   //Clock source|ʱ��Դ               TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_C
             -LOCK_Ext
  88   1              TIM_InitTypeDef.TIM_ClkOut = ENABLE;            //Programmable clock output|�ɱ��ʱ�����,       ENABLE,DI
             -SABLE
  89   1              TIM_InitTypeDef.TIM_Value = 41536;              //Initial load|װ�س�ֵ
  90   1              TIM_InitTypeDef.TIM_Run = ENABLE;               //�Ƿ�����|�Ƿ�����             ENABLE,DISABLE
  91   1              Timer_Inilize(Timer0, &TIM_InitTypeDef);
  92   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1287    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    108      20
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
